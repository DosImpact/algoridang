## REST API에 캐시를 적용시켜 보자.

1. 설치
2. CASE1 글로벌 캐시 적용
3. CASE2 개별 API 캐시 적용
4. CASE2+ HttpCacheInterceptor 만들기
5. Example Finance 모듈 적용기

### 설치

```
$ npm install cache-manager
$ npm install -D @types/cache-manager
```

### Redis 사용

```ts
docker run -d \
  -e REDIS_PASSWORD=dosimpact\
  -p 6380:6379 \
  --name redis_api_cache \
  --restart always \
  redis:latest /bin/sh -c 'redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}'
```

## AppMoudle에 캐시매니저 장착하기

```ts
import * as redisStore from 'cache-manager-redis-store';
@Module({
  imports: [
    CacheModule.register({
      store: redisStore,
      host: '127.0.0.1',
      port: 6379,
      ttl: 10, // 10초 캐슁
      max: 3, // 3개의 key값 유지
    }),
  ],
  controllers: [AppController],
  providers: [AppResolver],
})
```

## 2. CASE1 Controller 글로벌 캐시 적용

- 컨트롤러에 캐시인터셉터를 적용시키면
- 해당 endpoint는 자동으로 캐슁이 된다.
- 하지만 query,params,body에 대한 차이점은 무시한다.
- 변수가 없는 GET 요청에 적합

```ts
import {
  CacheInterceptor,
  CacheKey,
  CacheTTL,
  CACHE_MANAGER,
  Controller,
  Get,
  Inject,
  Query,
  Req,
  UseInterceptors,
} from '@nestjs/common';
import { Cache } from 'cache-manager';
import { Request } from 'express';

@UseInterceptors(CacheInterceptor)
@Controller()
export class AppController {
  constructor(
    @Inject(CACHE_MANAGER)
    private readonly cacheManager: Cache,
  ) {
    const test = async () => {
      // await cacheManager.set('name', 'dodo', { ttl: 1000 });
      console.log(await cacheManager.get('name'));
      console.log(await cacheManager.del('name'));
      console.log(await cacheManager.get('name'));
    };
    test();
  }

  @CacheKey('adder')
  @CacheTTL(3)
  @Get('/adder')
  async findAll(@Query('a') a: number, @Query('b') b: number): Promise<number> {
    const sleep = async (ms) => new Promise((res) => setTimeout(res, ms));
    console.log('wait...', a, '+', b);
    await sleep(3000);
    console.log('wait...', a, '+', b);
    return a + b;
  }
}
```

## 3. CASE2 개별 API 캐시 적용

- 수동으로 캐시 key를 관리하여, 특정 요청에대해서는 캐슁 처리를 하자.
- url에 대해서 캐슁하는 예

```ts
import {
  CacheInterceptor,
  CacheKey,
  CacheTTL,
  CACHE_MANAGER,
  Controller,
  Get,
  Inject,
  Query,
  Req,
  UseInterceptors,
} from '@nestjs/common';
import { Cache } from 'cache-manager';
import { Request } from 'express';

@Controller()
export class AppController {
  constructor(
    @Inject(CACHE_MANAGER)
    private readonly cacheManager: Cache,
  ) {
    const test = async () => {
      // await cacheManager.set('name', 'dodo', { ttl: 1000 });
      console.log(await cacheManager.get('name'));
      console.log(await cacheManager.del('name'));
      console.log(await cacheManager.get('name'));
    };
    test();
  }
  @Get('/adder2')
  async findAll2(
    @Query('a') a: number,
    @Query('b') b: number,
    @Req() request: Request,
  ): Promise<number> {
    const memo: string | null = await this.cacheManager.get(request.url);
    if (memo) {
      return Number(memo);
    }
    const sleep = async (ms) => new Promise((res) => setTimeout(res, ms));
    console.log('wait...', a, '+', b);
    await sleep(3000);
    console.log('wait...', a, '+', b);
    const res = a + b;
    await this.cacheManager.set(request.url, res);
    return res;
  }
}
```

## 4. CASE2+ HttpCacheInterceptor 만들기

- 목적 : 내가 원하는 캐시정책을 만들어 보자.
- POST의 body까지 동일하면 캐슁 해보자.

```ts
import { CacheInterceptor, ExecutionContext, Injectable } from '@nestjs/common';
import { Request } from 'express';

// (0) CacheInterceptor : path 만 동일하면 캐슁
// -문제점 : querystring이 다르면 다른요청이 와야하는데, 그렇지 못함

// (1) 캐시정책 : originalUrl (Params/query) 이 동일하면 캐슁
@Injectable()
export class HttpCacheInterceptor extends CacheInterceptor {
  trackBy(context: ExecutionContext) {
    const request = context.switchToHttp().getRequest<Request>();
    return request.originalUrl;
  }
}

// (2) 캐시정책 : protocol://hostname+originalUrl 이 동일하면 캐슁
@Injectable()
export class HttpHostCacheInterceptor extends CacheInterceptor {
  trackBy(context: ExecutionContext) {
    const request = context.switchToHttp().getRequest<Request>();
    return request.protocol + '://' + request.hostname + request.originalUrl;
  }
}

// (3) 캐시정책 : originalUrl (Params/query) + Body 동일하면 캐슁
@Injectable()
export class HttpBodyCacheInterceptor extends CacheInterceptor {
  trackBy(context: ExecutionContext) {
    const request = context.switchToHttp().getRequest<Request>();
    return request.originalUrl + JSON.stringify(request.body);
  }
}
```

```ts
import { HttpBodyCacheInterceptor } from './common/service/HttpCacheInterceptor';

@UseInterceptors(HttpBodyCacheInterceptor)
@Controller()
export class AppController {
  constructor(
    @Inject(CACHE_MANAGER)
    private readonly cacheManager: Cache,
  ) {}

  @Post('/adder3')
  async findAll3(@Body() { a, b }: { a: number; b: number }): Promise<number> {
    const sleep = async (ms) => new Promise((res) => setTimeout(res, ms));
    console.log('wait...', a, '+', b);
    await sleep(3000);
    console.log('wait...', a, '+', b);
    const res = a + b;
    return res;
  }
}
```

## CASE1 example - financeModule/controller 에 적용

### 1.env 설정을 해주어야 한다.

- ConfigModule을 import 해야, process.env 로 접근이 가능하다.
- App.module에 사실 global ConfigModule이 있긴하다.
- global ConfigModule의 ConfigService을 사용하려면
- Factory패턴을 사용해서, ConfigService을 inject 하도록 하자.
  [ref](https://stackoverflow.com/questions/64185541/how-to-use-configservice-in-nestjs-databasemodule)

```ts
import * as redisStore from 'cache-manager-redis-store';
import { ConfigModule, ConfigService } from '@nestjs/config';

@Module({
  imports: [
    ConfigModule.forRoot({
      envFilePath: process.env.NODE_ENV === 'dev' ? '.env.dev' : '.env.test',
      ignoreEnvFile: process.env.NODE_ENV === 'prod',
    }),
    TypeOrmModule.forFeature([Category, CategoryList, Corporation, DailyStock]),
    CacheModule.register({
      store: redisStore,
      host: process.env.REDIS_API_CACHE_HOST, // '127.0.0.1',
      port: +process.env.REDIS_API_CACHE_PORT, //6379,
      password: process.env.REDIS_API_CACHE_PASSWORD, //
      ttl: +process.env.REDIS_API_CACHE_TTL, // 10초 캐슁
      // max: 3, // 3개의 key값 유지
    }),
  ],
  controllers: [FinanceController],
  providers: [FinanceService],
  exports: [],
})
export class FinanceModule {}
```

### 2. 인터셉터 적용

- "/api/finance/corporations/00{}" 라고 캐시 키가 잡히는 모습
- "/api/finance/dailystock/006400?take=10{}" 라고 캐시 키가 잡히는 모습

```ts
import * as redisStore from 'cache-manager-redis-store';
@Module({
  imports: [
    TypeOrmModule.forFeature([Category, CategoryList, Corporation, DailyStock]),
    CacheModule.register({
      store: redisStore,
      host: '127.0.0.1',
      port: 6379,
      ttl: 10, // 10초 캐슁
      max: 3, // 3개의 key값 유지
    }),
  ],
  controllers: [FinanceController],
  providers: [FinanceService],
  exports: [],
})
export class FinanceModule {}
```

```ts
import { HttpBodyCacheInterceptor } from 'src/common/service/HttpCacheInterceptor';

@UseInterceptors(HttpBodyCacheInterceptor)
@Controller('/api/finance/')
export class FinanceController {
  constructor(private readonly financeService: FinanceService) {}

  // stock --- api

  // (1) 기업 리스트 출력
  @Get('corporations')
  async getCorporations() {
    return this.financeService.getCorporations();
  }
  // (2) 기업 리스트 출력 (검색어 기능 )
  @Get('corporations/:term')
  async getCorporationsWithTerm(@Param('term') term: string) {
    return this.financeService.getCorporationsWithTerm({ term });
  }

  // (3) 기업 리스트 출력 (검색어 기능 )
  @Get('corporation/:term')
  async getCorporation(@Param('term') term: string) {
    return this.financeService.getCorporation({ term });
  }

  // daily-stock --- api
  @Get('dailystock/:term')
  async getDailyStocks(
    @Param('term') term: string,
    @Query('skip') skip: number,
    @Query('take') take: number,
  ) {
    return this.financeService.getDailyStocks({ term, take, skip });
  }
}
```
