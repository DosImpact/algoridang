

## 순환 종속성

## STAR:S(상황)


- M모듈에는 M서비스가 있고, S모듈의 S서비스를 원한다.  
- S모듈에는 S서비스가 있고, M모듈의 M서비스를 원한다.  

- A class는 B class를 원하고  
- B class도 A class를 원해서 발생하는 원인이다.  


## STAR:T(테스크)

- M 사이드의 모듈에서, S모듈이 아직 생성자를 통해 만들어 지지 않았지만  
- 만들어져 있음을 가정 하도록 하자.   


## STAR:A(액션)
-   forwardRef(() => StrategyModule),
```ts
@Module({
  imports: [
    TypeOrmModule.forFeature([
      MemberInfo,
      LookupMemberList,
      OperationMemberList,
    ]),
    forwardRef(() => StrategyModule),
  ],
  controllers: [MemberController],
  providers: [MemberService],
  exports: [MemberService],
})
export class MemberModule {}
```
## STAR:R(결과)

- 다른 해결 방안  
- 1. 모듈 자체를 forward 모듈로 임포트(위 해결)  
- 2. provider를 forward 로 인젝션  

## ref
https://docs.nestjs.com/fundamentals/circular-dependency